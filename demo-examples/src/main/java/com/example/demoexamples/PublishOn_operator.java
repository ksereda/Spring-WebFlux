package com.example.demoexamples;

import java.util.function.Consumer;


import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

/**
 * Вы можете изменить поток выполнения (например, если мы хотим выполнить часть операторов в одном потоке, а часть в другом) - принимает планировщик в качестве аргумента
 * и позволяет изменить контекст выполнения на указанный планировщик. Его можно использовать в середине цепочки вызовов, и все остальные подписчики будут выполняться в
 * контексте указанного планировщика (в оригинале, который был указан).
 *
 * Как мы видим, все действия до publishOn() выполняются в главном потоке выполнения, а после вызова оператора publishOn – в другом, рабочем потоке планировщика Scheduler.
 *
 * Под капотом у оператора publishOn имеется очередь, куда записываются новые элементы, чтобы выделенный рабочий поток мог последовательно извлекать сообщения из очереди
 * и обрабатывать их. В этом примере мы хотели показать, что работа выполняется в отдельном потоке, следовательно, этап выполнения имеет асинхронную границу.
 * Как следствие теперь у нас есть два независимых этапа обработки потока данных. Важно подчеркнуть, что все элементы в реактивном потоке обрабатываются последовательно
 * (не конкурентно), благодаря чему всегда можно определить точный порядок следования событий. Это свойство также называется сериализуемостью. Оно означает, что элемент,
 * поступивший в publishOn, помещается в очередь, и как только наступит его черед, он будет извлечен из очереди и обработан. Обратите внимание, что обработка очереди
 * осуществляется единственным рабочим потоком, поэтому порядок элементов всегда предсказуем.
 */

public class PublishOn_operator {
    public static void main(String[] args) {

        Consumer<Integer> consumer = s -> System.out.println(s + " : " + Thread.currentThread().getName());

        Flux.range(1, 5)
                .map(i -> i + 2)
                .doOnNext(consumer)
                .publishOn(Schedulers.newElastic("First_PublishOn()_thread"))
                .doOnNext(consumer)
                .map(s -> s + 2)
                .subscribe(System.out::println);

    }
}
